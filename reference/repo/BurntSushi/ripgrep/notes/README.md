# ripgrep

## Repository Information

- **Repository**: [BurntSushi/ripgrep](https://github.com/BurntSushi/ripgrep)
- **Date Created**: 2025-11-22
- **Cloned to**: `/workspace/reference/repo/BurntSushi/ripgrep/code`
- **Star Count**: 50k+ stars, mature production Rust CLI tool

## Purpose

Analyzing ripgrep's CI/release pipeline to understand best practices for #199 (automated release PR generation for langstar project). ripgrep is one of the most widely-used Rust CLI tools and has a sophisticated release process.

## Key Findings

### CI Quality Gates (.github/workflows/ci.yml)

**Separate Jobs for Different Checks:**
1. **test** - Main test matrix (multi-platform, multi-arch)
2. **wasm** - WebAssembly target compilation
3. **rustfmt** - Code formatting check (`cargo fmt --all --check`)
4. **docs** - Documentation validation with `-D warnings`
5. **fuzz_testing** - Fuzz target compilation verification

**Test Matrix Strategy:**
- Multiple Rust versions: pinned (1.85.0), stable, beta, nightly
- Multiple platforms: Ubuntu, macOS, Windows (including ARM)
- Multiple architectures: x86_64, i686, aarch64, armv7, powerpc64, s390x, riscv64
- Both glibc and musl targets

**Cross-Compilation Approach:**
- Uses `cross` tool (pinned to v0.2.5 for stability)
- Downloads pre-compiled cross binaries (avoids 100+ dependency compile time)
- Matrix-driven: each target gets its own job
- Conditional: only Linux uses cross, native compilation for macOS/Windows

**Security Best Practices:**
- Minimal permissions: `contents: read` for CI
- Explicit permission documentation explaining least privilege principle
- Separate schedule trigger with restricted permissions

**Testing Strategy:**
- Tests with and without PCRE2 feature
- Integration tests for shell completions
- Hostname detection tests
- Flag availability tests
- Cross tests skip PCRE2 (doubles runtime with qemu)

### Release Pipeline (.github/workflows/release.yml)

**Trigger Mechanism:**
- Tag-based: `[0-9]+.[0-9]+.[0-9]+` pattern (semantic version)
- No workflow_dispatch (fully automated on tag push)

**Version Validation:**
```bash
if ! grep -q "version = \"$VERSION\"" Cargo.toml; then
  echo "version does not match Cargo.toml" >&2
  exit 1
fi
```
- **Critical**: Ensures Cargo.toml version matches tag before release
- Prevents accidental releases with mismatched versions

**Two-Phase Release:**
1. **create-release** job - Creates draft GitHub release first
2. **build-release** job - Builds artifacts and uploads to release

**Why this approach?**
- Release is created once, then multiple build jobs upload to it
- Uses job outputs to pass version between jobs
- Draft release allows review before publishing

**Permissions:**
- `contents: write` - Required for creating releases and uploading assets

**Cross-Compilation for Release:**
- Same cross-tool approach as CI (v0.2.5 pinned)
- Builds for 10+ targets (Linux musl/gnu, macOS x86_64/aarch64, Windows MSVC/GNU)
- Static linking: `PCRE2_SYS_STATIC: 1` for portability

**Binary Optimization:**
- Uses custom `release-lto` profile (likely more aggressive optimizations)
- Strips binaries using platform-specific tools:
  - macOS: native `strip`
  - Linux cross: Docker with `$TARGET-strip` tools (e.g., `x86_64-linux-musl-strip`)

**Artifact Packaging:**
- Structured directory: `ripgrep-$VERSION-$TARGET/`
- Includes:
  - Binary
  - LICENSE files (COPYING, UNLICENSE, LICENSE-MIT)
  - Documentation (README, CHANGELOG, FAQ, GUIDE)
  - Shell completions (bash, fish, PowerShell, zsh)
  - Man page
- Archives: `.tar.gz` (Unix) / `.zip` (Windows)
- SHA256 checksums for all artifacts

**Shell Completions Generation:**
- Generated at build time from binary's `--generate` flag
- Emulated architectures use qemu via Docker
- Ensures completions work on target architecture

**Debian Package:**
- Separate job: `build-release-deb`
- Uses `cargo-deb` tool
- Workaround: Debug build first to generate man/completions, then release build
- Package naming: `ripgrep_$VERSION-1_amd64.deb`
- SHA256 checksum included

### Changelog Generation

**Observation:** No automated changelog generation in CI/release workflows
- CHANGELOG.md is manually maintained
- Included in release artifacts but not generated by CI
- Suggests manual release process with human-written changelogs

### Token Handling

**Uses:** `GITHUB_TOKEN` (automatic GitHub Actions token)
- Sufficient for creating releases and uploading assets
- No need for PAT or GitHub App

**Permissions strategy:**
- CI: `contents: read` (minimal)
- Release: `contents: write` (required for releases)

### Release Gating

**Pre-release checks:**
- Version validation (tag matches Cargo.toml)
- Draft release creation (allows manual review before publishing)

**Post-merge checks:** None visible
- Release is triggered by tag push, not by PR merge
- Suggests manual tagging after PR approval

## Architecture

### Workflow Structure

```
.github/workflows/
├── ci.yml          # CI quality gates (format, test, docs, fuzz)
└── release.yml     # Release builds and asset creation
```

### CI Jobs Diagram

```
ci.yml
├── test (matrix: 15+ combinations)
│   ├── pinned/stable/beta/nightly Rust
│   ├── Ubuntu/macOS/Windows
│   └── x86_64/i686/aarch64/arm/powerpc64/s390x/riscv64
├── wasm (wasm32-wasip1 target)
├── rustfmt (formatting check)
├── docs (documentation validation)
└── fuzz_testing (fuzz target compilation)
```

### Release Jobs Diagram

```
release.yml (triggered by vX.Y.Z tag)
├── create-release
│   ├── Validate: tag == Cargo.toml version
│   ├── Create draft GitHub release
│   └── Output version for other jobs
├── build-release (matrix: 14 targets)
│   ├── Build with release-lto profile + PCRE2
│   ├── Strip binaries
│   ├── Package: binary + docs + completions + man
│   ├── Create archive + SHA256
│   └── Upload to draft release
└── build-release-deb
    ├── Generate completions/man from debug build
    ├── Build .deb package with cargo-deb
    ├── Create SHA256
    └── Upload to draft release
```

## Patterns & Anti-Patterns

### Strengths

1. **Pinned cross version** - Prevents breakage from upstream changes
2. **Version validation** - Catches version mismatches early
3. **Draft releases** - Allows review before publishing
4. **Minimal permissions** - Security best practice
5. **Extensive platform support** - 10+ targets
6. **Static linking** - Maximum portability
7. **Binary stripping** - Smaller download sizes
8. **Checksums** - Integrity verification
9. **Shell completions** - User experience
10. **Separate CI/release workflows** - Clean separation of concerns

### Potential Weaknesses

1. **No automated changelog** - Manual process prone to inconsistency
2. **No clippy in CI** - Only format/test/doc checks
3. **No cargo audit** - No dependency vulnerability scanning
4. **Manual tagging** - No PR-based release automation
5. **No pre-release CI gate** - Release workflow has version check, but no requirement that CI passes before tag

### Unique Approaches

1. **Emulated architecture testing** - Uses qemu via Docker for non-native targets
2. **Debug build for asset generation** - Workaround for cargo-deb limitation
3. **Pre-compiled cross binaries** - Faster CI (avoids 100+ dependency compile)

## Recommendations for Langstar #199

### Adopt

1. **Version validation** - Check tag matches Cargo.toml before release
2. **Draft releases** - Create draft, build artifacts, then publish
3. **Minimal permissions** - Use `contents: read` for CI, `contents: write` only for release
4. **Static linking** - For maximum portability
5. **Binary stripping** - Reduce artifact sizes
6. **SHA256 checksums** - For integrity verification

### Consider

1. **Add cargo clippy to CI** - ripgrep doesn't have it, but it's valuable
2. **Add cargo audit to CI** - Security vulnerability scanning
3. **Automated changelog with git-cliff** - Better than manual (ripgrep weakness)
4. **PR-based release automation** - workflow_dispatch on release branch
5. **Require CI pass before tag** - Branch protection on release branches

### Skip (for now)

1. **Extensive cross-compilation** - Langstar may not need 14 targets initially
2. **Debian packages** - Start with binary releases, add later if needed
3. **Emulated architecture testing** - Only if targeting exotic architectures

## Code Examples

### Version Validation Pattern

From `release.yml:28-34`:
```yaml
- name: Check that tag version and Cargo.toml version are the same
  shell: bash
  run: |
    if ! grep -q "version = \"$VERSION\"" Cargo.toml; then
      echo "version does not match Cargo.toml" >&2
      exit 1
    fi
```

**Why this matters:** Prevents releases with mismatched versions (e.g., tagged v1.2.3 but Cargo.toml says 1.2.2).

### Draft Release Pattern

From `release.yml:35-38`:
```yaml
- name: Create GitHub release
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  run: gh release create $VERSION --draft --verify-tag --title $VERSION
```

**Why this matters:** `--draft` flag allows building artifacts before making release public.

### Static Linking for Portability

From `release.yml:60-61`:
```yaml
# Build static releases with PCRE2.
PCRE2_SYS_STATIC: 1
```

**Why this matters:** Static linking means users don't need PCRE2 installed on their system.

## References

- ripgrep CI: `.github/workflows/ci.yml`
- ripgrep release: `.github/workflows/release.yml`
- cross tool: https://github.com/cross-rs/cross
- cargo-deb: https://github.com/kornelski/cargo-deb
